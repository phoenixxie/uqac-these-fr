%!TEX root = these.tex

\chapter{Introduction}

Au cours des récentes décennies, un grand nombre de systèmes de logiciels ont été introduits dans presque tous les domaines de notre vie \citep{clarke1999model}. Alors que les gens apprécient les facilités apportées par ces systèmes, il y a toujours le risque d'une défaillance dans les systèmes. Un échec comme un jeu vidéo ayant plusieurs bogues est ennuyeux mais tolérable, mais d'autres échecs sont fatals et inacceptables, par exemple des bogues dans les instruments médicaux, les systèmes de contrôle du véhicule automatisé ou les systèmes aéronautiques. Un exemple récent est le satellite astronomique japonais Hitomi, qui a causé une perte de 286 millions de dollars à Japan Aerospace Exploration Agency (JAXA). Il a été lancé le 17 février 2016 et a été officiellement déclaré perdu le 28 avril de la même année à cause d'une erreur de logiciel \citep{nature2016}.

\section{Contexte}

De toute évidence, la fiabilité d'un système est critique, et un système fiable doit avoir la capacité de fonctionner strictement selon sa spécification dans une période définie \citep{avivzienis2004basic}. La vérification et la validation de logiciels est le processus pour mesurer cette capacité et évaluer la qualité logicielle \citep{ieeestd2012}.

la vérification de l'exécution \citep{leucker2009brief} est une approche de la vérification et de la validation de logiciels qui est applicable pour vérifier si le comportement d'un système informatique satisfait ou viole certains propriétés. Normalement, la vérification de l'exécution n'a pas d'influence sur l'exécution du système en cours d'exécution, même si une violation des propriétés est détectée. À cet effet, un moniteur est utilisé pour analyser les traces finies collectées puis produire un verdict qui est généralement une valeur de vérité. Par conséquent, un système de vérification à l'exécution doit avoir au moins deux éléments essentiels: la collecte de données et l'évaluation de formules.

De nos jours, afin de répondre à la demande de l'analyse de la quantité de données de traces rapidement croissantes, diverses solutions ont été proposées. Certains chercheurs comme \cite{barre2012mapreduce} ont porté des méthodologies existantes aux cadres du calcul distribué. Cependant, peu importe le nombre de processeurs et de mémoires qu'un système de cloud possède, il y a toujours une limite pour leurs utilisations. Ainsi, d'autres chercheurs ont essayé d'optimiser les algorithmes, tels que \cite{havelund2001monitoring}.

Bitmap est une méthode efficace pour réduire le coût de l'espace grâce à sa structure concise, et les caractéristiques telles que le parallélisme du niveau de bits ou l'affinité du cache CPU sont en mesure d'accroître la performance des opérations \citep{culpepper2010efficient}. Il est largement appliqué dans les applications qui ont une exigence sérieuse de l'espace et de l'efficacité, par exemple les bases de données et les moteurs de recherche \citep{lemire2014}. Si un bitmap est limité, c'est-à-dire que la fraction de bits utilisés est faible, le bitmap peut occuper moins d'espace de stockage à l'aide de l'algorithme de compression de bitmap \citep{antoshenkov1995byte}.

Avant que les moniteurs analysent les traces, la collecte de données joue un rôle important \citep{casley1988collection}. Pour les différents systèmes, il existe des solutions correspondantes de la collecte de données. \cite{zwijze2005auditing} ont revu les techniques de collecte de données pour l'analyse de réseau. \cite{calabrese2011real} ont présenté un système de surveillance en temps réel avec la collecte de données à résolution élevée et à définition élevée de l'utilisation du téléphone cellulaire d'une ville italienne. \cite{shabtai2010applying} ont développé un système de détection d'intrusion basé sur l'hôte pour les appareils mobiles d'Android en rassemblant les données des événements de systèmes et des interactions d'utilisateurs. Comme cela est indiqué dans les exemples, divers moyens sont utilisés pour extraire et transférer les données vers la location où la vérification a lieu. La lumière visible est également un moyen de communication efficace, comme le suggèrent \cite{komine2004fundamental}, particulièrement dans des environnements restreints où le câble ou la communication radio sont peu pratiques, comme \cite{vasilescu2005data}.

Différents codes-barres ont été appliqués dans divers domaines à partir des systèmes traditionnels e-commerce à la croissance rapide d'appareils mobiles \citep{gao2007understanding}, parce que les codes-barres numériques fournissent une méthode simple mais précise avec un fable coût de distribution et de reconnaissance. Comparé avec le fameux code-barre 1-D UPC qui ne peut encoder que des chiffres, les codes-barres 2-D qui sont apparus à la fin des années 1980, peuvent non seulement encoder les données alphanumériques et les données même binaires, mais également fournir une capacité beaucoup plus grande. Quick Response Code (code QR) \citep{qrcode-about} est devenu l'un des 2-D codes-barres les plus populaires en raison de sa précision, sa capacité considérable, son impression relativement petite et sa grande efficacité. Il a été mis sur presque tous les types de surface visible, comme le papier, le téléphone et l'écran d'ordinateur, les vitrines des magasins \citep{okazaki2012benchmarking}.

\section{Objectifs du mémoire}

Les objectifs de cette recherche sont centrés sur le développement de méthodes ou de techniques qui est capable de fournir de l'assistance aux deux aspects mentionnés de la vérification de l'exécution: la collecte de données et l'évaluation de formules.

Le premier objectif principal et la contribution étaient de présenter une nouvelle méthode de la collecte de données et de discuter de sa faisabilité et de sa performance. Les codes QR sont considérés comme rapides et de grande capacité, et le fait le plus important est que son utilisation ne nécessite qu'une surface (par exemple l'écran) comme émetteur et une caméra comme récepteur, qui sont toutes deux devenues générales dans presque tous les ordinateurs portables et les téléphones mobiles ces dernières années. Si un code QR contenant une certaine quantité de données est considéré comme un paquet de données du réseau, une séquence de codes QR est similaire à un flux de données du réseau. Notre principale préoccupation ici était la bande passante du canal de la communication unidirectionnelle composée de codes QR, les facteurs critiques qui affectent la performance, ainsi que la méthode de l'application de ce canal de communication à notre pratique de la vérification de l'exécution.

Le deuxième objectif était de proposer une solution pour améliorer la performance du système de la vérification de l'exécution. Les bitmaps ont été démontrés par de nombreuses solutions pour leur capacité de l'amélioration de la performance. Parce que les états de logiques temporelles sont souvent exprimés avec les valeurs booléennes, c'est-à-dire vrai ou faux, les bitmaps sont prévus pour améliorer le calcul de formules de LTL. Par conséquent, l'une de nos contributions était la solution de correspondre des états de logiques temporelles à des bits et de concevoir des algorithmes nécessaires pour mettre en \oe{}uvre les opérations de LTL. Comme \cite{lemire2014} le suggèrent, un bitmap faible est une perte d'espace. Une contribution supplémentaire était donc l'observation de l'impact des algorithmes de compression bitmap sur le calcul de formules de LTL.

Il est important de mentionner que notre travail et la réalisation du canal de communication de code QR ont été publiés dans la revue IEEE Access, vol. 4, pp. 284-298, 2016. Une autre partie de notre recherche, l'évaluation de formules de LTL avec les manipulations de bitmap est en cours de révision pour sa publication dans les actes de la conférence internationale: Runtime Verification 2016 (RV'16) à Madrid, Espagne en 2016.

\section{Méthodologie}

Cette recherche a suivi une méthodologie en trois étapes.

La première étape était de développer le canal de la communication unidirectionnelle de codes QR qui correspond à notre deuxième objectif principal. Les paquets de données ont été encodés aux codes QR et décodés à partir des codes QR avec une librairie open source, et un protocole spécifique dédié à la sérialisation et à la transmission des données structurées sur des canaux de communication limités a été montré. Alors que l'expérience était en cours d'exécution, nous avons continué à optimiser notre solution basée sur le résultat de la première expérience pour améliorer le taux de correction et la vitesse de reconnaissance. Une webcam commune et un moniteur LED de 19 pouces ont été utilisés comme récepteur et émetteur dans l'expérience. Dans la dernière partie de cette étape, les codes QR étaient imprimés sur du papier de bureau et glissés devant la webcam afin de vérifier une allégation selon laquelle le protocole peut accepter des paquets de données entrantes sans ordre.

La deuxième étape a pour but de définir la relation de correspondance entre les états de logiques temporelles et les bitmaps, et aussi de concevoir les algorithmes des opérateurs de logiques temporelles. La séquence temporelle d'états d'une proposition atomique peut être mappée dans un bitmap où la valeur de chaque bit est 0 ou 1, ce qui correspond à juste titre à la valeur de type booléen d'états de logiques temporelles. Nous avons catégorisé les opérateurs habituels LTL définis dans \cite{huth2004} en trois groupes: les opérateurs de logiques propositionnelles, les opérateurs de logiques temporelles unaires et les opérateurs de logiques temporelles binaires. Chaque groupe avait ses caractéristiques et ses difficultés, en particulier les opérateurs de logiques temporelles binaires qui doivent énumérer deux bitmaps en même temps et prendre soin de plus de conditions que les autres groupes.

Dans la dernière étape, nous avons mis en œuvre notre solution avec un langage de programmation informatique populaire. Une interface de l'opération de bitmap a été extraite afin d'adapter les algorithmes de compression bitmap qui ont tous été mis en \oe{}uvre dans les librairies open source. Après le travail de programmation, une référence approfondie a été faite pour observer la vitesse de traitement sans compression ainsi que la performance de la vitesse et de l'espace avec les algorithmes de compression bitmaps.

\section{Organisation du mémoire}

Ce mémoire comprend cinq chapitres. Le contenu de chaque chapitre est le suivant.

Le premier chapitre introduit l'arrière-plan du mémoire, présente les tâches, décrit les méthodes appliquées dans la recherche et à la fin précise la structure du mémoire.

Le chapitre deux nous met au courant de la connaissance pertinente de la vérification de l'exécution, des logiques temporelles linéaires et introduit certains systèmes de la vérification de l'exécution.

Le chapitre trois est l'une des contributions de cette recherche. Il présente la solution du canal de la communication unidirectionnelle constitué de codes QR vacillants. Il est en fait une version traduite et reformatée de la publication ``Real-Time Streaming Communication with Optical Codes'' \citep{kxie7370891}.

Le chapitre quatre est une autre contribution, la solution de calcul de formules LTL avec l'aide des bitmaps. Le chapitre détaille la définition de la cartographie, les algorithmes et les expériences. Il est basé sur l'article ``Offline Evaluation of LTL Formul\ae{} with Bitmap Manipulations''.

Enfin, le chapitre cinq conclut cette recherche avec le résumé de nos contributions et un regard fixé sur notre travail à venir.