%!TEX root = these.tex

\chapter{Introduction}

Au cours des décennies récentes, un grand nombre de systèmes de logiciels ont été introduits dans presque tous les domaines de notre vie \citep{clarke1999model}. Alors que les gens apprécient les facilités apportées par ces systèmes, il y a toujours le risque de défaillance dans les systèmes. Un échec comme un jeu vidéo ayant plusieurs bogues est ennuyeux mais tolérable, mais il y a des autres échecs qui sont fatals et inacceptables, par exemple les bogues dans les instruments médicaux, les systèmes de contrôle du véhicule automatisé ou les systèmes aéronautiques. Un exemple récent est le satellite astronomique japonaise Hitomi, qui a apporté une perte de 286 millions dollars de Japan Aerospace Exploration Agency (JAXA). Il a été lancé le 17 Février 2016 et a officiellement déclaré perdu le 28 Avril en même année à cause d'une erreur de logiciel \citep{nature2016}.

\section{Contexte}

De toute évidence, la fiabilité d'un système est critique, et un système fiable doit avoir la capacité de fonctionner strictement selon sa spécification dans une période définie \citep{avivzienis2004basic}. La vérification et la validation de logiciels est un processus pour mesurer cette capacité et évaluer la qualité logicielle \citep{ieeestd2012}.

La vérification à l'exécution \citep{leucker2009brief} est une approche de la vérification et de la validation de logiciels qui est applicable pour vérifier si le comportement d'un système informatique satisfait ou viole des certains propriétés. Normalement, la vérification à l'exécution n'a pas d'influence sur l'exécution du système en cours d'exécution, même si une violation des propriétés est détectée. À cet effet, un moniteur est utilisé pour analyser la trace finie collectées puis produire un verdict qui est généralement une valeur de vérité. Par conséquent, un système de vérification à l'exécution doit avoir au moins deux éléments essentiels: la collecte de données et l'évaluation de formules.

De nos jours, afin de répondre à la demande de l'analyse de la quantité de donnés de trace rapidement croissantes, diverses solutions ont été proposées. Certains chercheurs comme \cite{barre2012mapreduce} ont porté des méthodologies existantes aux cadres du calcul distribué. Cependant, peu importe le nombre de processeurs et de mémoires a un système de cloud, il y a toujours une limite pour leurs utilisations. Ainsi, des autres chercheurs ont essayé d'optimiser les algorithmes, tels que \cite{havelund2001monitoring}.

Bitmap est une méthode efficace pour réduire le coût de l'espace grâce à sa structure concise, et les caractéristiques telles que le parallélisme du niveau de bits ou l'affinité du cache CPU sont en mesure d'accroître la performance des opérations \citep{culpepper2010efficient}. Il est largement appliqué dans les applications qui ont une exigence sérieuse de l'espace et de l'efficacité, par exemple les bases de données et les moteurs de recherche \citep{lemire2014}. Si un bitmap est peu, c'est-à-dire la fraction de bits utilisés est peu, le bitmap peut occuper moins d'espace de stockage à l'aide de l'algorithme de compression de bitmap \citep{antoshenkov1995byte}.

Avant que les moniteurs analysent les traces, la collecte de données joue un rôle important \citep{casley1988collection}. Pour les systèmes différents, il existe des solutions correspondantes de la collecte de données. \cite{zwijze2005auditing} ont revue les techniques de collecte de données pour l'analyse de réseau. \cite{calabrese2011real} ont présenté un système de surveillance en temps réel avec la collecte de données à la résolution élevée et à la définition élevée de l'utilisation du téléphone cellulaire d'une ville italienne. \cite{shabtai2010applying} ont développé un système de détection d'intrusion basé sur l'hôte pour les appareils mobiles d'Android en rassemblant les données des événements système et des interactions d'utilisateurs. Comme cela est indiqué dans les exemples, divers moyens sont utilisés pour extraire et transférer les données vers la location où la vérification a lieu. La lumière visible est également un moyen de communication efficace, comme le suggèrent \cite{komine2004fundamental}, particulièrement dans des environnements restreints où le câble ou la communication radio sont peu pratiques, comme \cite{vasilescu2005data}.

De différents codes-barres ont été appliquées dans divers domaines à partir des systèmes traditionnels e-commerce à l'augmentation rapide des appareils mobiles \citep{gao2007understanding}, parce que les codes-barres numériques fournissent une méthode simple mais précise avec une faiblesse du coût de la distribution et de la reconnaissance. Comparé avec le bien connu code-barre 1-D UPC qui ne peut encoder que les chiffres, les codes-barres 2-D qui apparaissaient à la fin des années 1980 peuvent non seulement encoder les données alphanumériques et les données même binaires, mais également fournir une capacité beaucoup plus grande. Quick Response Code (code QR) \citep{qrcode-about} est devenu l'un des 2-D codes-barres les plus populaires en raison de la précision, la capacité considérable, l'impression relativement petite et la grande efficacité. Il a été mis sur presque tous les types de surface visible, comme le papier, le téléphone et l'écran d'ordinateur, les vitrines des magasins \citep{okazaki2012benchmarking}.

\section{Objectives du mémoire}

Les objectifs de cette recherche sont centrées sur le développement de méthodes ou de techniques qui est capable de fournir de l'assistance aux deux aspects mentionnés de la vérification à l'exécution: la collecte de données et l'évaluation de formules.

Le premier objectif et contribution principaux étaient de présenter une nouvelle méthode de la collecte de données et de discuter de sa faisabilité et de sa performance. Les codes QR sont considéré comme rapide et de grande capacité, et le fait plus important est que son utilisation ne nécessite qu'une surface (par exemple l'écran) comme l'émetteur et une caméra comme le récepteur, qui sont tous deux  devenus générales dans presque tous les ordinateurs portables et les téléphones mobiles ces dernières années. Si un code QR contenant une certaine quantité de données est considéré comme un paquet de données du réseau, une séquence de codes QR est similaire à un flux de données du réseau. Notre préoccupation principale d'ici était la bande passante du canal de la communication unidirectionnelle composée de codes QR et les facteurs critiques qui affectent la performance, ainsi que la méthode de l'application de ce canal de communication à notre pratique de la vérification à l'exécution.

Le deuxième objectif était de proposer une solution pour améliorer la performance du système de la vérification à l'exécution. Les bitmaps sont démontrés par de nombreuses solutions pour sa capacité de l'amélioration de la performance. Parce que les états logiques temporelles sont souvent exprimées avec les valeurs booléennes, c'est-à-dire vrai ou faux, les bitmaps sont prévus pour améliorer le calcul de formules de LTL. Par conséquent, l'une de nos contributions était la solution de correspondre des états logiques temporelles à des bits et de concevoir des algorithmes nécessaires pour mettre en œuvre les opérations de LTL. Comme \cite{lemire2014} le suggèrent, un bitmap rare est une perte d'espace. Une contribution supplémentaire était donc l'observation de l'impact des algorithmes de compression de bitmaps sur le calcul de formules de LTL.

Il est important de mentionner que notre travail et réalisation du canal de communication de code QR a été publiée dans la revue IEEE Access, vol. 4, pp. 284-298, 2016. Une autre partie de notre recherche, l'évaluation de formules de LTL avec les manipulations de bitmaps est en cours de révision pour publier dans les actes de la conférence internationale: Runtime Verification 2016 (RV'16) à Madrid, Espagne en 2016.

\section{Méthodologie}

Cette recherche a suivi une méthodologie en trois étapes.

La première étape était de développer le canal de la communication unidirectionnelle de codes QR qui correspond à notre deuxième objectif principal. Les paquets de données ont été encodés aux code QR et décodés à partir des codes QR avec une librairie open source, et un protocole spécifique dédié à la sérialisation et à la transmission des données structurées sur les canaux de communication limités était introduit. Alors que l'expérience était en cours d'exécution, nous avons continué à optimiser notre solution basée sur le résultat de la première expérience pour améliorer le taux de correction et la vitesse de reconnaissance. Une webcam commune et un moniteur LED de 19 pouces étaient utilisés comme le récepteur et l'émetteur dans l'expérience. Dans la dernière partie de cette étape, les codes QR étaient imprimés sur les papiers de bureau et glissés devant la webcam afin de vérifier une allégation selon laquelle le protocole peut accepter les paquets de données entrantes sans ordre.

La deuxième étape a pour but de définir la relation de correspondance entre les états logiques temporelles et les bitmaps, et aussi de concevoir les algorithmes des opérateurs de logiques temporelles. La séquence temporelle d'états d'une proposition atomique peut être mappée dans un bitmap où la valeur de chaque bit est 0 ou 1, ce qui correspond à juste titre à la valeur de type booléen d'états logiques temporelles. Nous avons catégorisé les opérateurs LTL habituels définis dans \cite{huth2004} en trois groupes: les opérateurs de logiques propositionnelle, les opérateurs de logiques temporelles unaires et les opérateurs de logiques temporelles binaires. Chaque groupe avait ses caractéristiques et ses difficultés pour mettre en œuvre, en particulier les opérateurs de logiques temporelles binaires qui doivent énumérer deux bitmaps en même temps et prennent soin des conditions plus que les autres groupes.

Dans la dernière étape, nous avons mis en œuvre notre solution avec un langage de programmation informatique populaire. Une interface de l'opération de bitmap était constituée par abstraction afin d'adapter les algorithmes de compression de bitmaps qui sont toutes mises en œuvre dans les librairies open source. Après le travail de programmation, une référence approfondie a été faite pour observer la vitesse de traitement sans compression ainsi que la performance de la vitesse et de l'espace avec les algorithmes de compression de bitmaps.

\section{Organisation du mémoire}

Ce mémoire est composé de cinq chapitres. Le contenu de chaque section est la suivante.

Le premier chapitre introduit l'arrière-plan du mémoire, présente les tâches, décrit les méthodes appliquées dans la recherche et à la fin précise la structure du mémoire.

Le chapitre deux met au courant de la connaissance pertinente de la vérification à l'exécution, des logiques temporelles linéaires et introduit certains systèmes de la vérification à l'exécution.

Le chapitre trois est l'une des contributions de cette recherche. Il présente la solution du canal de la communication unidirectionnelle constitué des codes QR vacillants. Il est en fait une version traduite et reformatée de la publication ``Real-Time Streaming Communication with Optical Codes'' \citep{kxie7370891}.

Le chapitre quatre est une autre contribution, la solution de calcul de formules LTL avec l'aide des bitmaps. Le chapitre détaille la définition de la cartographie, les algorithmes et les expériences. Il est basé sur l'article ``Offline évaluation de LTL Formul\ae{} avec Bitmap Manipulations''.

Enfin, le chapitre cinq conclut cette recherche avec le résumé de nos contributions et notre regard fixé sur le travail à venir.