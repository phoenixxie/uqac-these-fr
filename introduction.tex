%!TEX root = these.tex

\chapter{Introduction}

Au cours des décennies récentes, un grand nombre de systèmes de logiciels ont été introduits dans presque tous les domaines de notre vie \citep{clarke1999model}. Alors que les gens apprécient les facilités apportées par ces systèmes, il y a toujours le risque de défaillance dans les systèmes. Un échec comme un jeu vidéo ayant plusieurs bogues est ennuyeux mais tolérable, mais il y a des autres échecs qui sont fatals et inacceptables, par exemple les bogues dans les instruments médicaux, les systèmes de contrôle du véhicule automatisé ou les systèmes aéronautiques. Un exemple récent est le satellite astronomique japonaise Hitomi, qui a apporté une perte de 286 millions d'dollars de Japan Aerospace Exploration Agency (JAXA). Il a été lancé le 17 Février 2016 et a officiellement déclaré perdu le 28 Avril en même année à cause d'une erreur de logiciel \citep{nature2016}.

\section{Contexte}

De toute évidence, la fiabilité d'un système est critique, et un système fiable doit avoir la capacité de fonctionner strictement selon sa spécification dans une période définie \citep{avivzienis2004basic}. La vérification et la validation de logiciels est un processus pour mesurer cette capacité et évaluer la qualité logicielle \citep{ieeestd2012}.

La vérification à l'exécution \citep{leucker2009brief} est une approche de la vérification et de la validation de logiciels qui est applicable pour vérifier si le comportement d'un système informatique satisfait ou viole des certains propriétés. Normalement, la vérification à l'exécution n'a pas d'influence sur l'exécution du système en cours d'exécution, même si une violation des propriétés est détectée. À cet effet, un moniteur est utilisé pour analyser la trace finie collectées puis produire un verdict qui est généralement une valeur de vérité. Par conséquent, un système de vérification à l'exécution doit avoir au moins deux éléments essentiels: la collecte de données et l'évaluation de formules.

De nos jours, afin de répondre à la demande de l'analyse de la quantité de donnés de trace rapidement croissantes, diverses solutions ont été proposées. Certains chercheurs comme \cite{barre2012mapreduce} ont porté des méthodologies existantes aux cadres du calcul distribué. Cependant, peu importe le nombre de processeurs et de mémoires a un système de cloud, il y a toujours une limite pour leurs utilisations. Ainsi, des autres chercheurs ont essayé d'optimiser les algorithmes, tels que \cite{havelund2001monitoring}.

Bitmap est une méthode efficace pour réduire le coût de l'espace grâce à sa structure concise, et les caractéristiques telles que le parallélisme du niveau de bits ou l'affinité du cache CPU sont en mesure d'accroître la performance des opérations \citep{culpepper2010efficient}. Il est largement appliqué dans les applications qui ont une exigence sérieuse de l'espace et de l'efficacité, par exemple les bases de données et les moteurs de recherche \citep{lemire2014}. Si un bitmap est peu, c'est-à-dire la fraction de bits utilisés est peu, le bitmap peut occuper moins d'espace de stockage à l'aide de l'algorithme de compression de bitmap \citep{antoshenkov1995byte}.

Avant que les moniteurs analysent les traces, la collecte de données joue un rôle important \citep{casley1988collection}. Pour les systèmes différents, il existe des solutions correspondantes de la collecte de données. \cite{zwijze2005auditing} a revue les techniques de collecte de données pour l'analyse de réseau. \cite{calabrese2011real} a présenté un système de surveillance en temps réel avec la collecte de données à la résolution élevée et à la définition élevée de l'utilisation du téléphone cellulaire d'une ville italienne. \cite{shabtai2010applying} a développé un système de détection d'intrusion basé sur l'hôte pour les appareils mobiles d'Android en rassemblant les données des événements système et des interactions d'utilisateurs. Comme cela est indiqué dans les exemples, divers moyens sont utilisés pour extraire et transférer les données vers la location où la vérification a lieu. La lumière visible est également un moyen de communication efficace, comme le suggère \cite{komine2004fundamental}, particulièrement dans des environnements restreints où le câble ou la communication radio sont peu pratiques, comme \cite{vasilescu2005data}.

De différents codes-barres ont été appliquées dans divers domaines à partir des systèmes traditionnels e-commerce à l'augmentation rapide des appareils mobiles \citep{gao2007understanding}, parce que les codes-barres numériques fournissent une méthode simple mais précise avec une faiblesse du coût de la distribution et de la reconnaissance. Comparé avec le bien connu code-barre 1-D UPC qui ne peut encoder que les chiffres, les codes-barres 2-D qui apparaissaient à la fin des années 1980 peuvent non seulement encoder les données alphanumériques et les données même binaires, mais également fournir une capacité beaucoup plus grande. Quick Response Code (code QR) \citep{qrcode-about} est devenu l'un des 2-D codes-barres les plus populaires en raison de la précision, la capacité considérable, l'impression relativement petite et la grande efficacité. Il a été mis sur presque tous les types de surface visible, comme le papier, le téléphone et l'écran d'ordinateur, les vitrines des magasins \citep{okazaki2012benchmarking}.

\section{Objectives du mémoire}

The objectives of this research center around the development of methods or techniques which is able to give assistance to the two mentioned aspects of runtime verification: data collection and formul\ae{} evaluation.

The first principle objective and contribution was to present a new method of data collection and discuss about its feasibility and performance. QR Code is considered fast and large-capacity, and more important is that its utilization needs only a surface (e.g. screen) as the transmitter and a camera as the receiver, both of which have become mainstream configuration of nearly every laptop and mobile phone in recent years. If a QR code containing certain amount of data is considered as a network data packet, a sequence of QR codes is like a network data stream. Our main concern here was the bandwidth of the one-way communication channel consisting of QR Codes and the critical factors which affect the performance, and also the method of applying this communication channel to our runtime verification practice.

The second objective was to propose a solution of improving the performance of runtime verification system. Bitmap has been proved by many solutions for its ability to improve the performance, and for the temporal logic states are often expressed with boolean values, i.e. true or false, Bitmap was anticipated to enhance the calculation of LTL formul\ae{}s. Therefore, one of our contributions was the solution of mapping temporal logic states to bits and design necessary algorithms to implement the operations of LTL. As \cite{lemire2014} suggests, a sparse bitmap is a waste of space. An additional contribution was thus the observation of the impact of the bitmap compression algorithms on the calculation of LTL formul\ae{}s.

It is important to mention that our work and achievement of the QR Code communication channel has been published in the journal IEEE Access, vol. 4, pp. 284-298, 2016. Another part of our research, LTL Formul\ae{} with Bitmap Manipulations, is under review for publication in the proceedings of the International Conference: Runtime Verification 2016 (RV'16) in Madrid, Spain in 2016.

\section{Methodology}

This research followed a three-steps methodology.

The first step was to develop the one-way QR-Codes communication channel which corresponds to our second principle objective. The data packet was encoded to and decoded from QR codes with an open source library, and a specific protocol dedicated to the serialization and transmission of structured data over limited communication channels was introduced. As the experiment was running, we kept optimizing our solution based on the early experiment result to improve the correction rate and the recognition speed. To take well knowledge of the performance with general devices, a common webcam and a 19-inch LED monitor were used as the receiver and the transmitter in the experiment. In the last part of this step, QR codes were printed on the office papers and swiped before the webcam in order to verify a claim that the protocol can accept incoming data packet without order.

The second step had for goal to define the mapping relationship between temporal logic states and bitmap and also to design the algorithms of the temporal logic operators. The temporal sequence of states of an atomic proposition can be mapped into a bitmap where the value of each bit is either 0 or 1, which rightly corresponds to the boolean-type value of temporal logic states. We categorized the usual LTL operators defined in \cite{huth2004} into three groups: propositional logic operators, unary temporal operators and binary temporal operators. Each group had its feature and difficult, especially the binary temporal operators which have to enumerate two bitmaps together and take care of more conditions than other groups.

In the last step, we implemented our solution with a popular computer programming language. An interface of the bitmap operation was abstracted in order to adapt with the bitmap compression algorithms all of which are implemented in open source libraries. After the programming job, a throughout benchmark was made to observe the process speed without compression and also the performance of both speed and space in condition with the compress algorithms.

\section{Thesis organization}

This thesis consists of five chapters. The content of each chapter is as follows:

Chapter one is an introduction to the background of the thesis, presents the tasks, describes the methods applied in the research and in the end states the thesis' structure.

Chapter two briefs the relevant knowledge of runtime verification, linear temporal logics and introduces some runtime verification systems.

Chapter three is one of the contributions from this research. It presents the solution of one-way communication channel consisting of flickering QR Codes. It is actually a reformatted version of the publication ``Real-Time Streaming Communication with Optical Codes'' \citep{kxie7370891}.

Chapter four is another contribution, the solution of calculating LTL formul\ae{}s with the assistance of bitmaps. The chapter details the definition of mapping, the algorithms and the experiment. It is based on the paper ``Offline Evaluation of LTL Formul\ae{} with Bitmap Manipulations''.

Finally, chapter five concludes this research with the summary of our contributions and looks forward to our future work.