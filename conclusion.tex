%!TEX root = these.tex

\chapter{Conclusion et perspectives}

La vérification et la validation du logiciel est un élément critique du génie logiciel et de la gestion de projet. Les gens ont appris cela de plusieurs leçons dans le passé allant des ``crashed games'' à la catastrophe fatale. Comparée avec les techniques traditionnelles de la vérification du logiciel, la vérification de l'exécution est relativement nouvelle. Elle a sa racine dans d'autres techniques et elle a ses propres caractéristiques. Ces dernières années, une grande quantité de travaux et de temps ont été investis dans divers aspects de ce domaine. Des chercheurs se concentrent sur l'amélioration et l'application de différentes variantes de LTL, et d'autres s'efforcent d'inventer de plus en plus de cadres génériques.

Bien que le réseau se soit déjà très répandu sur la terre, de nombreux milieux du réseau ont été exploités et divers protocoles réseau ont été proposés, il y a encore des endroits où le câble et la radio sans fil ne sont pas parvenus, comme les déserts ou les lieux sous-marins, ou de l'environnement où le câble et la radio sans fil sont indésirables ou même interdits, par exemple, dans les avions, les hôpitaux, les mines ou les usines pétrochimiques. Même dans ces limites, la vérification du logiciel est aussi essentielle que celle dans les lieux de réseautage couverts. Visible light communication (VLC) est une solution efficace dans ces situations et elle a réussi de nombreux cas, qui nous ont incité à penser à une méthode d'utilisation de codes optiques pour le travail de communication de données. Un code QR est une étiquette encodée optique qui est capable de stocker a une quantité considérable de données et d'encoder et de décoder efficacement les données, ce qui nous a donné la confiance de l'appliquer dans notre solution.

Dans la première partie de notre recherche, l'objectif était de concevoir et de mettre en \oe{}uvre un canal de communication unidirectionnel de codes QR. Nous avons utilisé le langage de programmation informatique Java et la librairie bien connue ZXing. Dans les expériences précédentes, nous avons testé les caractéristiques d'un flux de données QR et trouvé qu'en raison de la limitation des matériels que nous avons utilisés, le taux de perte de données était impossiblement zéro et il a augmenté vite alors que la taille de données de chaque image croissait. Ainsi, d'une part nous avons réussi à améliorer le taux de reconnaissance de codes QR en ajustant les options de la librairie ZXing et de la caméra. D'autre part, nous avons proposé le protocole BufferTannen qui est en charge de la division, de la transformation, et dans une certaine mesure de la compression de données à transmettre. Le résultat final présenté dans la Section \ref{sec:qr:experiments} prouve la faisabilité de notre solution. Cette partie de notre recherche a été publiée dans le journal \textit{IEEE Access} en 2016.

Chaque système du logiciel, que ce soit des systèmes de téléphones mobiles, des applications web ou des systèmes de cloud computing, doit garantir son bon fonctionnement et répondre en temps afin de réduire la perte ou d'éviter la catastrophe. L'exigence de la vérification du logiciel pour chaque système pourrait être similaire, comme le suggère la Section \ref{sec:rv:frameworks} qui a présenté plusieurs cadres de la vérification de l'exécution qui partagent les mêmes fonctionnalités. Toutefois, l'échelle de chaque système du logiciel varie beaucoup. Par exemple, un smartphone dispose d'une mémoire beaucoup plus petite et d'un processeur beaucoup plus lent qu'un poste de travail populaire, sans compter un système de cloud computing comme Amazon EC2. Lors du développement d'un système de la vérification de l'exécution pour un smartphone, l'usage de la mémoire et du processeur est toujours la principale préoccupation. D'une autre manière, même dans un système informatique qui a une énorme mémoire et un puissant processeur, il y a toujours une limite à la mémoire et au processeur. Par conséquent, il existe beaucoup de travaux sur l'amélioration de systèmes de la vérification de l'exécution. Certains travaux visent à distribuer le calcul à un cluster de serveurs, tandis que certains réussissent à optimiser les algorithmes pour trouver une meilleure solution.

Notre deuxième objectif était de trouver un moyen d'améliorer la vitesse d'évaluation de formules LTL. Un bitmap est une structure de données compacte et efficace qui existe dans un grand nombre d'applications. Un verdict émis par le moniteur en mode hors ligne de la vérification de l'exécution est une valeur de vérité qui n'a que deux valeurs, qui peut être facilement mise en correspondance avec un bit d'un bitmap. Nous avons également conçu quelques algorithmes pour mettre en \oe{}uvre les opérateurs LTL avec des bitmaps mappés. \cite{lemire2014} suggèrent qu'un bitmap creux peut être bien compressé, et comme nous en avons discuté dans la Section \ref{sec:bm:ltlbitmap}, le bitmap de sortie des algorithmes a des séquences plus longues de bits consécutifs de 1s ou de 0s que les bitmaps d'entrée. Par conséquent, nous avons intégré des algorithmes de compression bitmap dans notre solution. Les résultats expérimentaux démontrent la performance et la faisabilité de notre solution, et prouvent que l'utilisation de la compression bitmap peut rendre notre solution plus rapide et plus espace-économique avec certains algorithmes. Cette partie de notre recherche est également écrite dans un article qui est encore en cours de révision pour sa publication dans les actes de la conférence internationale: Runtime Verification 2016 (RV'16) à Madrid, Espagne en 2016.

Notre canal de communication de codes QR appuie seulement le transfert de données unidirectionnel, ce qui a comme résultat que même notre programme renvoie la même image de données plusieurs fois, nous ne pouvons toujours pas nous assurer que le récepteur ait reçu toutes les données. Une communication bidirectionnelle semble une réponse raisonnable à ce problème, et elle permet aussi de renvoyer des données sur la demande et augmente donc la bande passante effective.

Un bitmap a des bits de 1s ou de 0s, donc la valeur $inconcluante$ de LTL$_3$ ne peut pas être facilement mise en \oe{}uvre. Par conséquent, notre solution ne fonctionne que pour le monitoring en mode hors ligne. L'Évaluation en ligne de formules LTL avec l'aide de bitmaps serait un grand défi mais quoique intéressant. En outre, la parallélisation de notre solution dans un système de cloud computing est également très intéressante.
