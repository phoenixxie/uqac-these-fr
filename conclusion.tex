%!TEX root = these.tex

\chapter{Conclusion and future work}

Software verification and validation is a critical part in software engineering and project management. People have learned this from lots of lessons in the past ranging from crashed games to fatal disaster. Comparing with traditional techniques of software verification, runtime verification is relatively new. It has root in other techniques and it has its own feature. In recent years, a great amount of work and time has been invested in various aspects of this area. Some researchers focus on the improvement and applications of various variant of LTL, and some others manage to develop more and more generic frameworks.

Although network has already covered much place on earth, many networking mediums have been exploited and various networking protocols have been proposed, there is still some place where cable and wireless radio have not reached, like deserts or underwater, or some environment where both cable and wireless radio are undesirable or even forbidden, for example, in planes, hospitals, mines or petro-chemical plants. Even under these limitations, software verification is as essential as in networking-covered places. Visible light communication (VLC) is an efficient solution in these situations and has many successful solutions, which enlightened us to think of a method of using optical codes for the data communication work. QR code is encoded optical label which is able to store considerable data and to efficiently encode and decode data, which gave us the confidence to apply it in our solution.

In the first part of our research, the goal was to design and implement an one-way QR Code communication channel. In the development, we used the computer programming language Java and the well-known QR Code library ZXing. In early experiment, we tested the characteristics of a QR data stream and found that due to the limitation of the hardwares we used, the data loss rate was impossibly zero and it grew fast as the data size of each frame increased. Therefore on one hand we managed to improve the recognition rate of QR codes by adjusting the options of the ZXing library and the camera. On the other hand we proposed the protocol BufferTannen which is in charge of splitting, marshaling, and to some extend compressing the data to transmit. The final result presented in Section \ref{sec:qr:experiments} proves the feasibility of our solution. This part of our research has been published in the journal IEEE Access in 2016.

Every software system, no matter operation systems of mobile phones, web applications, or cloud computing system, needs to guarantee its smooth running and response in time for the exceptions in order to reduce the loss or avoid the disaster. The requirement of software verification for each system could be similar, as is suggested in Section \ref{sec:rv:frameworks} which introduced several runtime verification frameworks sharing same functionalities. However, the scale of every software systems varies a lot. For example, a smartphone has much lower memory and slower processor than a mainstream workstation, not to mention a cloud computing system like Amazon EC2. When developing a RV system for a smartphone, the usage of memory and processor is always the main concern. In another way, even in a computer system which has huge memory and power processor, there is always a limit to the memory and the processor. Therefore, there are many researches on the improvement of RV systems. Some tried to distribute the computing to a cluster of servers, some managed to optimize the algorithms or find a better solution.

Our second objective was to find a way to improve the speed of LTL formul\ae{}s' calculation. Bitmap is a compact and efficient data structure which has a lot of applications and solutions. A verdict issued by offline runtime verification monitor is two-valued truth value, which can be easily mapped into a bit in a bitmap. We also designed a few algorithms to implement the LTL operators with mapped bitmaps. \cite{lemire2014} suggests that a sparse bitmap can be well compressed, and as we discussed in Section \ref{sec:bm:ltlbitmap}, the output bitmap from the algorithms has longer consecutive 1/0 sequence than the input. Therefore we integrated bitmap compression algorithms into our solution. The experiment results demonstrate the performance and the feasibility of our solution, and prove that the usage of bitmap compression can make our solution faster and more space-efficient with certain algorithms. This part of our research is also written in a paper which is still under review for publication in the proceedings of the International Conference: Runtime Verification 2016 (RV'16) in Madrid, Spain in 2016.

\section*{Future work}

Our QR code communication channel supports only one-way data transfer, resulting that even our program resends the same data frame for several times, we still cannot ensure that the receiver has got all the data. A bidirectional communication seems an answer to this problem, and it can also allow to resend data on demand and thus increase the effective bandwidth.

A bitmap has bits of either 1 or 0, so the $inconclusive$ value of LTL$_3$ cannot be easily implemented. As a result, our solution works only in the offline monitoring mode. To support the online mode is a big but interesting challenge. In addition, making our solution parallelized to be able to run in a computing cloud is also very intriguing.